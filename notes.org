* Notes on my solutions

** TODO Day 1
I am working with buffers and more imperative features of lisp and so this feels very non-functional way of programming. I have not done that in a while and it feels very weird. The first part is working correctly but my second part seems to give the wrong answer. I don't understand which part I am missing.
#+begin_src elisp :exports both
  (load-file "src/day1.el")
  (count-par (read-line "inputs/day1"))
#+end_src

#+RESULTS:
: 74

** Day 2
Reading lines and working with strings is still the hardest part of the problem for me. I somehow read each dimension string as a lisp symbol and worked it from there.
#+begin_src elisp :exports both
  (load-file "src/file-utils.el")
  (load-file "src/day2.el")
  (let ((ls (read-lines "inputs/day2")))
    (values (total ls 'req-area) 
	    (total ls 'ribbon-length)))
#+end_src

#+RESULTS:
| 1588178 | 3783758 |

** Day 3
Un-interleaving was a bit tricky to write as I cannot do full recursion. I also used ~seq-reduce~ instead of ~reduce~ to work with a given initial value.
#+begin_src elisp :exports both
  (load-file "src/file-utils.el")
  (load-file "src/day3.el")
  (multiple-value-bind (fst snd)
      (unzip (string-to-list (read-file "inputs/day3")))
    (length (remove-duplicates (append (visited fst)
				       (visited snd))
			       :test 'eq-pos)))
#+end_src

#+RESULTS:
: 2639

** Day 4
What's with MD5 collisions. Do I need to implement a part of the algorithm? I also skipped one in aoc16.

** Day 5
Started using test-simple package from elpa to do a few tests in file. Part one is simple enough and with small sized entries we can just compose filters rather than try to get all the requirements in one iteration of the string. 
#+begin_src elisp :exports both
  (load-file "src/file-utils.el")
  (load-file "src/day5.el")
  (let ((lines (read-lines "inputs/day5")))
    (count-if 'nice lines))
#+end_src

#+RESULTS:
: 236

Part two is quite a different altogether. My previous encounters with such problems were swiftly taken care of as the languages I used were prolog and mercury which were very suitable for such search problems.
#+begin_src elisp :exports both
  (load-file "src/file-utils.el")
  (load-file "src/day5.el")
  (let ((lines (read-lines "inputs/day5")))
    (count-if 'nice2 lines))
#+end_src

#+RESULTS:
: 51

** Day 6
Multi-dimensional arrays are not supported in Emacs. I had to do a ad-hoc implementation of two dimensional array as a vector in row-major-order. It seems to work fine. ~(defun (setf fun-name))~ style setters are also not supported in emacs-lisp, there is a macro ~gv-define-simple-setter~ that is recommended to create setters but I have not used it yet.

Now coming to the specific problem the method itself is straight forward but my answer seems to be wrong. I should check it for a few small cases and find the error.

** Day 7
Just plain recursive evaluation is not working. Max recursive depth ~max-lisp-eval-depth~ is being exceeded. Test cases are working fine. I need to memoize and find a strategy to evaluate from the bottom or something. I also need to plane data structures for my strategy. For small programs simple lists suffice but when things get a least bit complicated keeping it all straight in my head is a pain.
The example test case given in the problem
#+begin_src elisp :exports both
(load-file "src/file-utils.el")
(load-file "src/day7.el")
(defconst grid (mapcar 'parse-joint (read-lines "inputs/day7test")))
(get-val '(:wire "h") (create-network grid))
#+end_src

#+RESULTS:
: 65412

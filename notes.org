* Notes on my solutions

** TODO Day 1
I am working with buffers and more imperative features of lisp and so this feels very non-functional way of programming. I have not done that in a while and it feels very weird. The first part is working correctly but my second part seems to give the wrong answer. I don't understand which part I am missing.
#+begin_src elisp :exports both
  (load-file "src/day1.el")
  (count-par (read-line "inputs/day1"))
#+end_src

#+RESULTS:
: 74

** Day 2
Reading lines and working with strings is still the hardest part of the problem for me. I somehow read each dimension string as a lisp symbol and worked it from there.
#+begin_src elisp :exports both
  (load-file "src/file-utils.el")
  (load-file "src/day2.el")
  (let ((ls (read-lines "inputs/day2")))
    (values (total ls 'req-area) 
	    (total ls 'ribbon-length)))
#+end_src

#+RESULTS:
| 1588178 | 3783758 |

** Day 3
Un-interleaving was a bit tricky to write as I cannot do full recursion. I also used ~seq-reduce~ instead of ~reduce~ to work with a given initial value.
#+begin_src elisp :exports both
  (load-file "src/file-utils.el")
  (load-file "src/day3.el")
  (multiple-value-bind (fst snd)
      (unzip (string-to-list (read-file "inputs/day3")))
    (length (remove-duplicates (append (visited fst)
				       (visited snd))
			       :test 'eq-pos)))
#+end_src

#+RESULTS:
: 2639

** TODO Day 4
What's with MD5 collisions. Do I need to implement a part of the algorithm? I also skipped one in aoc16.

** Day 5
Started using test-simple package from elpa to do a few tests in file. Part one is simple enough and with small sized entries we can just compose filters rather than try to get all the requirements in one iteration of the string. 
#+begin_src elisp :exports both
  (load-file "src/file-utils.el")
  (load-file "src/day5.el")
  (let ((lines (read-lines "inputs/day5")))
    (count-if 'nice lines))
#+end_src

#+RESULTS:
: 236

Part two is quite a different altogether. My previous encounters with such problems were swiftly taken care of as the languages I used were prolog and mercury which were very suitable for such search problems.
#+begin_src elisp :exports both
  (load-file "src/file-utils.el")
  (load-file "src/day5.el")
  (let ((lines (read-lines "inputs/day5")))
    (count-if 'nice2 lines))
#+end_src

#+RESULTS:
: 51

** Day 6
Multi-dimensional arrays are not supported in Emacs. I had to do a ad-hoc implementation of two dimensional array as a vector in row-major-order. It seems to work fine. ~(defun (setf fun-name))~ style setters are also not supported in emacs-lisp, there is a macro ~gv-define-simple-setter~ that is recommended to create setters but I have not used it yet.

Now coming to the specific problem the method itself is straight forward but my answer seems to be wrong. I should check it for a few small cases and find the error.

** Day 7
Just plain recursive evaluation is not working. Max recursive depth ~max-lisp-eval-depth~ is being exceeded. Test cases are working fine. I need to memoize and find a strategy to evaluate from the bottom or something. I also need to plane data structures for my strategy. For small programs simple lists suffice but when things get a least bit complicated keeping it all straight in my head is a pain.
The example test case given in the problem
#+begin_src elisp :exports both
(load-file "src/file-utils.el")
(load-file "src/day7.el")
(defconst grid (mapcar 'parse-joint (read-lines "inputs/day7test")))
(get-val '(:wire "h") (create-network grid))
#+end_src

#+RESULTS:
: 65412

The problem was solved by just setting the wire to a const number after evaluating it once. This only worked since the circuit was static. In part two I just set the wire ~b~ to the value and my solution to part one gave me the answer. I need to create the circuit twice because the ~get-val~ function destructively memoizes the circuit.
#+begin_src elisp :exports both
  (defconst main-grid (mapcar 'parse-joint (read-lines "inputs/day7")))
  (let* ((main-network (create-network main-grid))
	 (partone (get-val '(:wire "a") (create-network main-grid))))
    (puthash "b" (list :const partone) main-network)
    (values partone (get-val '(:wire "a") main-network)))
#+end_src

#+RESULTS:
| 16076 | 2797 |

** Day 8
This is quite straight forward to program but debugging would have been a pain because printed representation and in memory representation are different. I worked with list of char ascii values so it went smoothly. For the second path I do not need to actually encode the string, just counting the special chars will be enough. I still wrote a function ~encode-string~ to do it.
#+begin_src elisp :exports both
  (load-file "src/file-utils.el")
  (load-file "src/day8.el")
  (values  (reduce '+ (mapcar 'mem-string-diff (read-lines "inputs/day8")))
	   (reduce '+ (mapcar 'encode-len-diff (read-lines "inputs/day8"))))
#+end_src

#+RESULTS:
| 1333 | 2046 |

** Day 9
I am familiar with the shortest path algorithm by Dijsktra but now I require the Hamiltonian path. Declarative searching such as this is very well suited for Prolog. Maybe I'll re-implement it in prolog too.

A brute force prolog implementation good enough.
#+begin_src prolog :exports both
  :- consult("src/hamiltonian-path.pl").
  :- distances("inputs/day9", X),
     findall(Z, trail(X, Y, Z), Zs),
     min_list(Zs, Ans1), max_list(Zs, Ans2),
     format('~w ~w~n', [Ans1, Ans2]).
#+end_src

#+RESULTS:
: 251 898

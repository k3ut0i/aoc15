* Haskell notes

** DONE Day7
   CLOSED: [2021-08-17 Tue 19:41]
   There is a lot of needless complexity and my solution is unclear.
   - I should try to use input parser as a separate function rather than linking it to the ~Read~ class. Here I had to make ~Con~ a data type when a ~type Con = Map String ConIn~ would have sufficed.
   - The recursion is non-trivial, ~evalCon~ ->  ~evalWire~ -> ~eval~ -> ~evalCon~. It could be simpler.
   - Must try reader and state monads and see how that solution compares to this.
     
** Day8

** DONE Day10
   CLOSED: [2021-09-29 Wed 12:30]
   Pretty straightforward implementation. 

** DONE Day 11
   CLOSED: [2021-09-29 Wed 14:59]
   - couple of char functions ~ord~, ~chr~.
   - good use of ~until~
   - could have improved ~double2s~ for checking that at least 2 unique items exist in a list 

** DONE Day 12
   CLOSED: [2021-10-02 Sat 18:04]
   I first thought of using regex's to match and extract all numbers in a given string. While I was searching for haskell regex libraries, I can just as easily be done using parser combinators.
   So let me see how this goes.
   Hmm, I wrote a integer scanner from the ground up.
   Now for the second part, I might as well use a JSON library. Does the problem setter expect a ad-hoc JSON parser to be written?
   <2021-10-02 Sat> I am now using *aeson* for reading the JSON file.
   - Data.HashMap, ByteString, Data.Text
   - Data.Scientific, Data.Aeson
   Used a few external packages 

** Day 13
   Brute force enumeration of permutations followed by scoring each.
   - circular pairings part is a bit messy
   - used ~concatMap~ a couple of times

** Day 14
   - I should start using ~Map~ data structures rather than working with key-value lists.
   - All calculations need the read-only input data, so I will try out ~Reader~ monad and finally see how it works out.
